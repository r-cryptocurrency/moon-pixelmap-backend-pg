# MOONPLACE PIXEL MAP BACKEND (POSTGRES)

## 1. Overview

The MOONPLACE Pixel Map Backend is a Node.js application built with Express.js and PostgreSQL. It serves as the backend for the MOONPLACE pixel map project. Its primary responsibilities include:

*   **Blockchain Event Monitoring**: Continuously scans the Arbitrum Nova blockchain (via Alchemy) for events emitted by the deployed `PixelMap.sol` smart contract.
*   **Data Persistence**: Stores processed event data, pixel block states (current owner, URI), ownership history, URI update history, and user names into a PostgreSQL database.
*   **Image Generation**: Periodically fetches pixel data from the database, retrieves individual pixel images (from URIs, including base64 encoded JSON data URIs), and generates a composite PNG image of the entire 100x100 pixel map.
*   **API Service**: Exposes RESTful API endpoints to:
    *   Serve the generated pixel map image.
    *   Provide detailed JSON data for all minted pixel blocks.
    *   Provide data for individual pixel blocks.
    *   Report the application's synchronization status.

The backend is designed to ensure data consistency between the blockchain state and the local database, providing a reliable data source for the frontend application.

## 2. Setup

1.  **PostgreSQL Database**:
    *   Ensure you have a PostgreSQL server running.
    *   Create a dedicated database and a user with appropriate permissions.
2.  **Environment Variables**:
    *   Copy the `example.env` file (if one exists) to a new file named `.env`.
    *   Update the `.env` file with your PostgreSQL connection details (host, port, database name, user, password) and your Alchemy API key (`ALCHEMY_API_KEY`).
    ```env
    DB_HOST=your_db_host
    DB_PORT=5432
    DB_NAME=your_db_name
    DB_USER=your_db_user
    DB_PASSWORD=your_db_password
    ALCHEMY_API_KEY=your_alchemy_api_key
    PORT=3001 # Optional: Port for the backend server
    LOG_LEVEL=info # Optional: Logging level (e.g., debug, info, warn, error)
    ```
3.  **Install Dependencies**:
    ```bash
    npm install
    ```
4.  **Initialize Database**:
    *   The application will attempt to create the necessary tables on startup if they don't exist.
    *   To manually reset and recreate all tables, run:
    ```bash
    npm run reset-db
    ```
    This script drops all existing tables (CASCADE) and then recreates them according to the schema defined in `src/utils/db.js`.

5.  **Run the Application**:
    *   For development (with Nodemon, if configured):
        ```bash
        npm run dev
        ```
    *   For production:
        ```bash
        npm start
        ```

## 3. Project Structure

```
moon-pixelmap-backend-pg/
├── logs/                     # Log files generated by Winston
│   ├── combined.log
│   ├── errors.log
│   ├── exceptions.log
│   └── rejections.log
├── src/
│   ├── config.js             # Configuration (DB, Alchemy, Contract ABI/Addresses)
│   ├── index.js              # Main application entry point (Express server setup)
│   ├── routes/               # Express route handlers
│   │   ├── pixelmap.js       # API for the full pixel map image
│   │   ├── pixels.js         # API for individual and all pixel data (JSON)
│   │   └── status.js         # API for application status
│   ├── scripts/
│   │   └── resetDb.js        # Script to reset and initialize the database
│   ├── services/
│   │   └── eventProcessor.js # Logic for processing specific blockchain events
│   └── utils/
│       ├── blockProcessor.js # Scans blockchain for new events
│       ├── db.js             # Database connection, table creation/reset
│       ├── imageGenerator.js # Generates the composite pixel map image
│       ├── imageProcessor.js # (Currently seems unused or legacy)
│       └── logger.js         # Winston logger configuration
├── .env                      # Environment variables (ignored by git)
├── example.env               # Example environment file
├── package.json              # Project dependencies and scripts
└── README.md                 # This file
```

## 4. Key Components and Functions

### `src/index.js`
*   Initializes the Express application.
*   Sets up middleware (CORS, JSON parsing, request logging).
*   Mounts API routes from the `src/routes/` directory.
*   Starts the blockchain event processing loop (`processEventsFromLastBlock`).
*   Starts the periodic image generation (`startImageGenerationInterval`).

### `src/config.js`
*   `DB_CONFIG`: Object containing database connection parameters (read from `.env`).
*   `SERVER_CONFIG`: Server configuration (e.g., port).
*   `alchemySettings`: Alchemy API key and network settings.
*   `CONTRACT_CONFIG`:
    *   `provider`: RPC URL for the blockchain.
    *   `address`: Deployed smart contract addresses (keyed by network ID).
    *   `abi`: The ABI (Application Binary Interface) of the `PixelMap.sol` smart contract.

### `src/utils/db.js`
*   `pool`: `pg.Pool` instance for database connections.
*   `createTables()`:
    *   Defines and executes `CREATE TABLE IF NOT EXISTS` statements for:
        *   `events`: Stores raw event data from the smart contract (unique by `transaction_hash`, `log_index`).
        *   `pixel_blocks`: Stores the current state of each pixel block (x, y, URI, current owner, timestamps).
        *   `pixel_block_owners`: History of ownership for each pixel block.
        *   `pixel_block_uri_history`: History of URI updates for each pixel block.
        *   `transactions`: (Potentially for storing general transaction info - usage might need review).
        *   `users`: Stores user addresses and their associated names from the `Named` event.
    *   Creates PL/pgSQL trigger functions and triggers to automatically update `updated_at` timestamps on row updates for `pixel_blocks` and `users`.
*   `resetDatabase()`: Drops all relevant tables (using `CASCADE` to handle foreign key dependencies).

### `src/utils/blockProcessor.js`
*   `getLastProcessedBlock()`: Retrieves the last successfully processed block number from the `events` table or returns a default starting block.
*   `processEventsFromLastBlock()`:
    *   Periodically fetches new blocks from the blockchain via Alchemy SDK.
    *   Retrieves all relevant smart contract events within those blocks.
    *   Fetches timestamps for these blocks.
    *   Processes events in batches, wrapped in database transactions:
        *   Inserts raw event data into the `events` table.
        *   Delegates event-specific logic to `processEventLog()` in `src/services/eventProcessor.js`.
    *   Updates the record of the last processed block.

### `src/services/eventProcessor.js`
*   `convertTokenIdToXY(tokenId)`: Converts a `tokenId` to `{x, y}` coordinates.
*   `calculateTokenId(x, y)`: Converts `{x, y}` coordinates to a `tokenId`.
*   `processEventLog(eventLogFromEthers, eventTimestamp, dbClient, contract, logger, ethersInstance)`:
    *   Main dispatcher function that routes event data to specific handler functions based on `eventName`.
*   `handleBuyEvent(..., buyer, x, y, ...)`:
    *   Called for `Buy` and `BatchBuy` events.
    *   Fetches `tokenURI` from the contract for the given `x, y`.
    *   Upserts data into `pixel_blocks` (owner, URI).
    *   Inserts into `pixel_block_owners` history.
*   `handleTransferEvent(..., from, to, tokenId, ...)`:
    *   Called for `Transfer` events.
    *   If `from` is the zero address (mint):
        *   Fetches `tokenURI`.
        *   Upserts into `pixel_blocks` (owner, URI, ensuring `created_at` is set).
    *   If a regular transfer:
        *   Updates `current_owner` in `pixel_blocks`.
    *   Inserts into `pixel_block_owners` history for both cases.
*   `handleUpdateEvent(..., updater, x, y, uri, ...)`:
    *   Called for `Update` events.
    *   Updates `uri` and `timestamp` in `pixel_blocks` for the given `x, y` (verifies `updater` is `current_owner`).
    *   Inserts the new URI, owner, and timestamp into `pixel_block_uri_history`.
*   `handleNamedEvent(..., user, name, ...)`:
    *   Called for `Named` events.
    *   Upserts the `user` address and `name` into the `users` table.
*   `handleOwnershipTransferredEvent(...)`:
    *   Logs contract ownership changes (not pixel ownership).

### `src/utils/imageGenerator.js`
*   `generatePixelMapImage()`:
    *   Creates a 1000x1000 canvas (100x100 blocks, each 10x10 pixels).
    *   Draws a default background/grid.
    *   Fetches all `pixel_blocks` with non-null URIs from the database.
    *   For each pixel block:
        *   If the URI is a `data:application/json;base64,...` string, it decodes it, parses the JSON, and extracts the actual image URI from the `image` field.
        *   Loads the image from the (potentially extracted) URI using `canvas.loadImage()`.
        *   Draws the loaded image onto the main canvas at the correct `x, y` position.
    *   Caches the generated canvas buffer (`imageCache`).
    *   Logs detailed statistics about URI processing.
*   `getPixelMapImage()`: Returns the `imageCache` if available.
*   `startImageGenerationInterval(intervalMs)`: Periodically calls `generatePixelMapImage()` to keep the cache fresh.

### `src/utils/logger.js`
*   Configures a Winston logger instance with multiple transports (console, file for combined logs, file for errors, etc.).
*   Provides a `createChildLogger(serviceName)` helper to create context-specific loggers.

### `src/routes/`
*   **`pixelmap.js` (`/api/pixelmap`)**:
    *   `GET /`: Serves the cached pixel map PNG image generated by `imageGenerator.js`. Includes ETag and Last-Modified headers for caching.
*   **`pixels.js` (`/api/pixels`)**:
    *   `GET /`: Returns a JSON array of all pixel blocks from the `pixel_blocks` table (x, y, URI, current owner, timestamp) where `current_owner` is not null.
    *   `GET /:x/:y`: Returns JSON data for a specific pixel block.
*   **`status.js` (`/api/status`)**:
    *   `GET /`: Returns a JSON object with the current application status, including the last processed block number and the timestamp of the last successful image generation.

## 5. Database Schema

The database schema is defined and managed in `src/utils/db.js`. Key tables include:

*   **`events`**: Stores raw event data from the smart contract.
    *   `id, block_number, transaction_hash, log_index, event_type, args, timestamp`
*   **`pixel_blocks`**: Current state of each pixel on the map.
    *   `id, x, y, uri, current_owner, timestamp, created_at, updated_at`
    *   Unique constraint on `(x, y)`.
*   **`pixel_block_owners`**: History of ownership changes.
    *   `id, x, y, owner, timestamp, transaction_hash, block_number`
    *   Foreign key `(x, y)` references `pixel_blocks(x, y)`.
*   **`pixel_block_uri_history`**: History of URI updates for pixels.
    *   `id, x, y, uri, owner, timestamp, transaction_hash, block_number`
    *   Foreign key `(x, y)` references `pixel_blocks(x, y)`.
*   **`transactions`**: General transaction information (currently minimal usage).
    *   `id, block_number, transaction_hash, from_address, to_address, value, timestamp`
*   **`users`**: Stores user addresses and associated names.
    *   `id, address, user_name, created_at, updated_at`
    *   Unique constraint on `address`.

Triggers are in place to automatically update the `updated_at` fields in `pixel_blocks` and `users` tables whenever a row is updated.

## 6. Future Considerations / Potential Improvements
*   Enhanced error handling and retry mechanisms for blockchain interactions and image loading.
*   More sophisticated caching strategies.
*   API rate limiting and security enhancements.
*   Scalability improvements for handling a larger number of events or pixels.
*   Detailed metrics and monitoring.
*   WebSockets for real-time updates to the frontend.
