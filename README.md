# MOONPLACE PIXEL MAP BACKEND (POSTGRES)

## 1. Overview

The MOONPLACE Pixel Map Backend is a Node.js application built with Express.js and PostgreSQL. It serves as the backend for the MOONPLACE pixel map project. Its primary responsibilities include:

*   **Blockchain Event Monitoring**: Continuously scans the Arbitrum Nova blockchain (via Alchemy) for events emitted by the deployed `PixelMap.sol` smart contract.
*   **Data Persistence**: Stores processed event data, pixel block states (current owner, URI), ownership history, URI update history, and user names into a PostgreSQL database.
*   **Image Generation**: Periodically fetches pixel data from the database, retrieves individual pixel images (from URIs, including base64 encoded JSON data URIs), and generates a composite PNG image of the entire 100x100 pixel map.
*   **API Service**: Exposes RESTful API endpoints to:
    *   Serve the generated pixel map image.
    *   Provide detailed JSON data for all minted pixel blocks.
    *   Provide data for individual pixel blocks.
    *   Report the application's synchronization status.

The backend is designed to ensure data consistency between the blockchain state and the local database, providing a reliable data source for the frontend application.

## 2. Setup

1.  **PostgreSQL Database**:
    *   Ensure you have a PostgreSQL server running.
    *   Create a dedicated database and a user with appropriate permissions.
2.  **Environment Variables**:
    *   Copy the `example.env` file (if one exists) to a new file named `.env`.
    *   Update the `.env` file with your PostgreSQL connection details (host, port, database name, user, password) and your Alchemy API key (`ALCHEMY_API_KEY`).
    ```env
    DB_HOST=your_db_host
    DB_PORT=5432
    DB_NAME=your_db_name
    DB_USER=your_db_user
    DB_PASSWORD=your_db_password
    ALCHEMY_API_KEY=your_alchemy_api_key
    PORT=3001 # Optional: Port for the backend server
    LOG_LEVEL=info # Optional: Logging level (e.g., debug, info, warn, error)
    ```
3.  **Install Dependencies**:
    ```bash
    npm install
    ```
4.  **Initialize Database**:
    *   The application will attempt to create the necessary tables on startup if they don't exist.
    *   To manually reset and recreate all tables, run:
    ```bash
    npm run reset-db
    ```
    This script drops all existing tables (CASCADE) and then recreates them according to the schema defined in `src/utils/db.js`.

5.  **Run the Application**:
    *   For development (with Nodemon, if configured):
        ```bash
        npm run dev
        ```
    *   For production:
        ```bash
        npm start
        ```

## 3. Project Structure

```
moon-pixelmap-backend-pg/
├── logs/                     # Log files generated by Winston
│   ├── combined.log
│   ├── errors.log
│   ├── exceptions.log
│   └── rejections.log
├── src/
│   ├── config.js             # Configuration (DB, Alchemy, Contract ABI/Addresses)
│   ├── index.js              # Main application entry point (Express server setup)
│   ├── routes/               # Express route handlers
│   │   ├── pixelmap.js       # API for the full pixel map image
│   │   ├── pixels.js         # API for individual and all pixel data (JSON)
│   │   └── status.js         # API for application status
│   ├── scripts/
│   │   └── resetDb.js        # Script to reset and initialize the database
│   ├── services/
│   │   └── eventProcessor.js # Logic for processing specific blockchain events
│   └── utils/
│       ├── blockProcessor.js # Scans blockchain for new events
│       ├── db.js             # Database connection, table creation/reset
│       ├── imageGenerator.js # Generates the composite pixel map image
│       ├── imageProcessor.js # (Currently seems unused or legacy)
│       └── logger.js         # Winston logger configuration
├── .env                      # Environment variables (ignored by git)
├── example.env               # Example environment file
├── package.json              # Project dependencies and scripts
└── README.md                 # This file
```

## 4. Key Components and Functions

### `src/index.js`
*   Initializes the Express application.
*   Sets up middleware (CORS, JSON parsing, request logging).
*   Mounts API routes from the `src/routes/` directory.
*   Starts the blockchain event processing loop (`processEventsFromLastBlock`).
*   Starts the periodic image generation (`startImageGenerationInterval`).

### `src/config.js`
*   `DB_CONFIG`: Object containing database connection parameters (read from `.env`).
*   `SERVER_CONFIG`: Server configuration (e.g., port).
*   `alchemySettings`: Alchemy API key and network settings.
*   `CONTRACT_CONFIG`:
    *   `provider`: RPC URL for the blockchain.
    *   `address`: Deployed smart contract addresses (keyed by network ID).
    *   `abi`: The ABI (Application Binary Interface) of the `PixelMap.sol` smart contract.

### `src/utils/db.js`
*   `pool`: `pg.Pool` instance for database connections.
*   `createTables()`:
    *   Defines and executes `CREATE TABLE IF NOT EXISTS` statements for:
        *   `events`: Stores raw event data from the smart contract (unique by `transaction_hash`, `log_index`).
        *   `pixel_blocks`: Stores the current state of each pixel block (x, y, URI, current owner, timestamps).
        *   `pixel_block_owners`: History of ownership for each pixel block.
        *   `pixel_block_uri_history`: History of URI updates for each pixel block.
        *   `transactions`: (Potentially for storing general transaction info - usage might need review).
        *   `users`: Stores user addresses and their associated names from the `Named` event.
    *   Creates PL/pgSQL trigger functions and triggers to automatically update `updated_at` timestamps on row updates for `pixel_blocks` and `users`.
*   `resetDatabase()`: Drops all relevant tables (using `CASCADE` to handle foreign key dependencies).

### `src/utils/blockProcessor.js`
*   `getLastProcessedBlock()`: Retrieves the last successfully processed block number from the `events` table or returns a default starting block.
*   `processEventsFromLastBlock()`:
    *   Periodically fetches new blocks from the blockchain via Alchemy SDK.
    *   Retrieves all relevant smart contract events within those blocks (in 10-block batches for Alchemy free tier).
    *   Fetches timestamps for these blocks.
    *   Processes events in batches, wrapped in database transactions:
        *   Inserts raw event data into the `events` table.
        *   Delegates event-specific logic to `processEventLog()` in `src/services/eventProcessor.js`.
    *   Updates the record of the last processed block.
*   `EVENT_BATCH_SIZE`: Default set to 10 blocks (Alchemy free tier limit, can be increased for paid plans).

### `src/services/eventProcessor.js`
*   `convertTokenIdToXY(tokenId)`: Converts a `tokenId` to `{x, y}` coordinates.
*   `calculateTokenId(x, y)`: Converts `{x, y}` coordinates to a `tokenId`.
*   `processEventLog(eventLogFromEthers, eventTimestamp, dbClient, contract, logger, ethersInstance)`:
    *   Main dispatcher function that routes event data to specific handler functions based on `eventName`.
*   `handleBuyEvent(..., buyer, x, y, ...)`:
    *   Called for `Buy` and `BatchBuy` events.
    *   Fetches `tokenURI` from the contract for the given `x, y`.
    *   Upserts data into `pixel_blocks` (owner, URI).
    *   Inserts into `pixel_block_owners` history.
*   `handleTransferEvent(..., from, to, tokenId, ...)`:
    *   Called for `Transfer` events.
    *   If `from` is the zero address (mint):
        *   Fetches `tokenURI`.
        *   Upserts into `pixel_blocks` (owner, URI, ensuring `created_at` is set).
    *   If a regular transfer:
        *   Updates `current_owner` in `pixel_blocks`.
    *   Inserts into `pixel_block_owners` history for both cases.
*   `handleUpdateEvent(..., updater, x, y, uri, ...)`:
    *   Called for `Update` events.
    *   Updates `uri` and `timestamp` in `pixel_blocks` for the given `x, y` (verifies `updater` is `current_owner`).
    *   Inserts the new URI, owner, and timestamp into `pixel_block_uri_history`.
*   `handleNamedEvent(..., user, name, ...)`:
    *   Called for `Named` events.
    *   Upserts the `user` address and `name` into the `users` table.
*   `handleOwnershipTransferredEvent(...)`:
    *   Logs contract ownership changes (not pixel ownership).

### `src/utils/imageGenerator.js`
*   `generatePixelMapImage()`:
    *   Creates a 1000x1000 canvas (100x100 blocks, each 10x10 pixels).
    *   Draws a default background/grid.
    *   Fetches all `pixel_blocks` with non-null URIs from the database.
    *   For each pixel block:
        *   If the URI is a `data:application/json;base64,...` string, it decodes it, parses the JSON, and extracts the actual image URI from the `image` field.
        *   Loads the image from the (potentially extracted) URI using `canvas.loadImage()`.
        *   Draws the loaded image onto the main canvas at the correct `x, y` position.
    *   Caches the generated canvas buffer (`imageCache`).
    *   Logs detailed statistics about URI processing.
*   `getPixelMapImage()`: Returns the `imageCache` if available.
*   `startImageGenerationInterval(intervalMs)`: Periodically calls `generatePixelMapImage()` to keep the cache fresh.

### `src/utils/logger.js`
*   Configures a Winston logger instance with multiple transports (console, file for combined logs, file for errors, etc.).
*   Provides a `createChildLogger(serviceName)` helper to create context-specific loggers.

### `src/routes/`
*   **`pixelmap.js` (`/api/pixelmap`)**:
    *   `GET /`: Serves the cached pixel map PNG image generated by `imageGenerator.js`. Includes ETag and Last-Modified headers for caching.
*   **`pixels.js` (`/api/pixels`)**:
    *   `GET /`: Returns a JSON array of all pixel blocks from the `pixel_blocks` table (x, y, URI, current owner, timestamp) where `current_owner` is not null.
    *   `GET /:x/:y`: Returns JSON data for a specific pixel block. **Protected with coordinate validation (0-99 range).**
*   **`pixels-update.js` (`/api/pixels-update`)**:
    *   `POST /`: Updates a pixel block's image. **Protected with:**
        - Input validation middleware (coordinates, address, image size)
        - Rate limiting (20 requests per 15 minutes)
        - Parameterized queries to prevent SQL injection
*   **`users.js` (`/api/users`)**:
    *   `POST /`: Creates or updates user connection. **Protected with address validation.**
    *   `GET /:address`: Returns user data for a specific address. **Protected with address validation.**
*   **`status.js` (`/api/status`)**:
    *   `GET /`: Returns a JSON object with the current application status, including the last processed block number and the timestamp of the last successful image generation.

### `src/utils/validation.js`
*   **Input validation middleware** to prevent injection attacks:
    *   `validateCoords`: Validates x,y coordinates are integers 0-99
    *   `validateAddressInBody`: Validates Ethereum address format in request body
    *   `validateAddressInParams`: Validates Ethereum address format in URL params
    *   `validateImageInBody`: Validates base64 image data and size limits (200KB max)

## 5. Database Schema

The database schema is defined and managed in `src/utils/db.js`. Key tables include:

*   **`events`**: Stores raw event data from the smart contract.
    *   `id, block_number, transaction_hash, log_index, event_type, args, timestamp`
*   **`pixel_blocks`**: Current state of each pixel on the map.
    *   `id, x, y, uri, current_owner, timestamp, created_at, updated_at`
    *   Unique constraint on `(x, y)`.
*   **`pixel_block_owners`**: History of ownership changes.
    *   `id, x, y, owner, timestamp, transaction_hash, block_number`
    *   Foreign key `(x, y)` references `pixel_blocks(x, y)`.
*   **`pixel_block_uri_history`**: History of URI updates for pixels.
    *   `id, x, y, uri, owner, timestamp, transaction_hash, block_number`
    *   Foreign key `(x, y)` references `pixel_blocks(x, y)`.
*   **`transactions`**: General transaction information (currently minimal usage).
    *   `id, block_number, transaction_hash, from_address, to_address, value, timestamp`
*   **`users`**: Stores user addresses and associated names.
    *   `id, address, user_name, created_at, updated_at`
    *   Unique constraint on `address`.

Triggers are in place to automatically update the `updated_at` fields in `pixel_blocks` and `users` tables whenever a row is updated.

# MOONPLACE PIXEL MAP BACKEND (POSTGRES)

## Current Status (as of October 30, 2025)
✅ **Working Features:**
- Blockchain event monitoring and processing (10-block batches for Alchemy free tier)
- Database persistence with full history tracking
- Image generation from on-chain URIs
- Secure REST API endpoints with input validation
- Winston logging system with rate limit violation tracking
- Rate limiting on all API routes
- SQL injection protection via parameterized queries

✅ **Recently Fixed:**
- SQL injection vulnerability patched with validation middleware
- Rate limiting implemented (100 req/15min general, 20 req/15min for writes)
- Input validation middleware for coordinates and addresses
- Alchemy API batch size reduced to 10 blocks (free tier limit)

⚠️ **Known Issues:**
- Named events only store hash, not actual name
- No API authentication (public endpoints)
- CORS allows all origins (needs restriction for production)
- Image processing validation could be enhanced

## TODO Lists

### 🔴 Immediate (Security Critical):
1. ✅ ~~**Fix SQL injection** in `routes/pixels-update.js`~~ - COMPLETED (using parameterized queries + validation)
2. ✅ ~~**Add rate limiting**~~ - COMPLETED (express-rate-limit: 100/15min general, 20/15min writes)
3. **Implement API authentication** (API keys or JWT)
4. **Restrict CORS** origins for production (currently allows all)
5. ✅ ~~**Add input validation** middleware~~ - COMPLETED (`src/utils/validation.js`)
6. **Fix Named event handling** - consider alternative storage for actual names
7. **Add helmet middleware** for security headers
8. **Address npm audit vulnerabilities** (13 found: 2 low, 1 moderate, 8 high, 2 critical)

### 🟡 Near Term (1-2 weeks):
1. **Add WebSocket support** for real-time updates
2. **Implement chat system backend**:
   - Create chat tables in PostgreSQL
   - Add Socket.IO server
   - User authentication for chat
3. **Add database connection pooling config**
4. **Implement image validation and size limits**
5. **Add API documentation** (Swagger/OpenAPI)
6. **Create health check endpoint**
7. **Add metrics collection** (Prometheus)

### 🟢 Long Term (1+ month):
1. **Implement caching layer** (Redis)
2. **Add GraphQL API** alongside REST
3. **Create admin dashboard backend**
4. **Add analytics and reporting**
5. **Implement IPFS integration** for decentralized storage
6. **Add notification system** for pixel updates
7. **Create backup and recovery system**
